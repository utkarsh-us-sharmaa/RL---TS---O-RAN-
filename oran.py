# -*- coding: utf-8 -*-
"""ORAN-hua.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qq02OhKqSD6YaaiiW-g1Su5OhXMuxPGO
"""

# comment out this if you run on google colab
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import csv
import random

random.seed(2024)
# Function to generate random throughput based on slice value
def generate_throughput(slice_value):
    if slice_value == 1:
        return random.randint(85, 200)
    elif slice_value == 2:
        return random.randint(30, 300)
    elif slice_value == 3:
        return random.randint(1500, 90000)
    elif slice_value == 4:
        return random.randint(900, 8000)
    else:
        return None

# Open CSV file for writing
with open('data.csv', mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['id', 'slice', 'x', 'y', 'throughput(Kbps)', 'allocatedCell'])

    # Generate 250 rows of data
    for _ in range(250):
        # random.seed(2024)
        slice_value = random.randint(1, 4)
        x = random.randint(0, 99)
        y = random.randint(0, 99)
        throughput = generate_throughput(slice_value)
        writer.writerow([(_+1), slice_value, x, y, throughput, 0])

import pandas as pd
cells = pd.read_csv('data_old/cells.csv')
cells2 = pd.read_csv('data_old/cells2.csv')
ues = pd.read_csv('data_old/data.csv')
"""Plotting the scenario with anchored cells"""

import matplotlib.pyplot as plt
import numpy as np

# Define circular areas
circle_centers = []
circle_radii = []
for i in range (0, len(cells['x'])):
  circle_centers.append((cells['x'][i], cells['y'][i]))
  circle_radii.append(cells['radius'][i])

# Plotting
plt.figure(figsize=(10, 10))

# Plot circular areas and add label numbers
for i, (center, radius) in enumerate(zip(circle_centers, circle_radii)):
    if radius == 6:
        circle = plt.Circle(center, radius, alpha=0.3, color='red')
    elif radius == 30:
        circle = plt.Circle(center, radius, alpha=0.3, color='blue')
    else:
        circle = plt.Circle(center, radius, alpha=0.3, color='lightblue')
    plt.gca().add_patch(circle)

    # Add label number inside the circle
    plt.text(center[0], center[1], str(i+1), color='black', ha='center', va='center')

# Adjust plot settings
plt.title('Arrangement of the cells in a 100 km x 100 km space')
plt.axis([0, 100, 0, 100])

#Code to see the UE points scattered on the plane
a = ues['x'].to_list()
b = ues['y'].to_list()
plt.scatter(a, b)

# Show the plot
plt.show()

"""Plotting the BASELINE scenario"""

import matplotlib.pyplot as plt
import numpy as np

# Define circular areas
circle_centers = []
circle_radii = []
for i in range (0, len(cells2['x'])):
  circle_centers.append((cells2['x'][i], cells2['y'][i]))
  circle_radii.append(cells2['radius'][i])

# Plotting
plt.figure(figsize=(10, 10))

# Plot circular areas and add label numbers
for i, (center, radius) in enumerate(zip(circle_centers, circle_radii)):

    circle = plt.Circle(center, radius, alpha=0.3, color='lightblue')

    plt.gca().add_patch(circle)

    # Add label number inside the circle
    plt.text(center[0], center[1], str(i+1), color='black', ha='center', va='center')

# Adjust plot settings
plt.title('Arrangement of the cells in a 100 km x 100 km space')
plt.axis([0, 100, 0, 100])

a = ues['x'].to_list()
b = ues['y'].to_list()
plt.scatter(a, b)

# Show the plot
plt.show()

"""**Our Policy**"""

import json
policy = {
    '1': {
        # Preference 1: Non-anchored Macro cell, since we only need GBR and there are no latency or delay requirements
        'p1': 'macro',
        # Preference 2: Non-anchored Pico cell, if there's no available macro cell coverage, we can use the nearest pico cell
        'p2': 'pico',
        'p3': 'anchored'
    },
    '2':{
        # Preference 1: Non-anchored macro cell, since the utility is just to sync up the IoT device or an activity not requiring high throughputs
        'p1': 'macro',
        # Preference 2: Because of increased ranges of the anchored cell, to keep the GBR up if there's an emergency signal needed to be sent and pico is too far
        'p2': 'anchored',
        'p3': 'pico'
    },
    '3':{
        # Preference 1: For an emBB use-case, we will need the highest available throughput
        'p1': 'pico',
        # Preference 2: Anchored cell since it would ensure lesser bursts/buffers in the connection
        'p2': 'anchored',
        'p3': 'macro'
    },
    '4':{
        # Preference 1: To minimize the latency, anchored connections would be given the first ask
        'p1': 'anchored',
        # Preference 2: To mitigate the latency delays, macro cells preferred because of their increased ranges as when compared against pico cells
        'p2': 'macro',
        'p3': 'pico'
    }
}

"""**Baseline Policy**"""

import json
policy2 = {
    '1': {
        # Preference 1: Non-anchored Macro cell, since we only need GBR and there are no latency or delay requirements
        'p1': 'macro',
        # Preference 2: Non-anchored Pico cell, if there's no available macro cell coverage, we can use the nearest pico cell
        'p2': 'pico',
        # 'p3': 'anchored'
    },
    '2':{
        # Preference 1: Non-anchored macro cell, since the utility is just to sync up the IoT device or an activity not requiring high throughputs
        'p1': 'macro',
        # Preference 2: Because of increased ranges of the anchored cell, to keep the GBR up if there's an emergency signal needed to be sent and pico is too far
        # 'p2': 'anchored',
        'p2': 'pico'
    },
    '3':{
        # Preference 1: For an emBB use-case, we will need the highest available throughput
        'p1': 'pico',
        # Preference 2: Anchored cell since it would ensure lesser bursts/buffers in the connection
        # 'p2': 'anchored',
        'p2': 'macro'
    },
    '4':{
        # Preference 1: To minimize the latency, anchored connections would be given the first ask
        # 'p1': 'anchored',
        # Preference 2: To mitigate the latency delays, macro cells preferred because of their increased ranges as when compared against pico cells
        'p1': 'macro',
        'p2': 'pico'
    }
}

#Function to calculate Euclidean distance between a UE and a cell
import math
def dist(uex, uey, cellx, celly):
  return math.sqrt((uex - cellx)**2 + (uey - celly)**2)

# Firsts: UEs which were allocated their first preference
# Allocated: the actual allocated cell IDs
# oloads: Number of times the allocation WOULD HAVE lead to an overload
# unmanaged: Number of UEs which could not be allocated any cell
firsts = []
allocated = []
oloads = []
unmanaged = 0

def findCell(id, preference, x, y, throughput, first):
  if preference=='macro':
    availableCells = cells[cells.pico==0]
    availableCells = availableCells[availableCells.anchored==0]

  if preference=='pico':
    availableCells = cells[cells.pico==1]
    availableCells = availableCells[availableCells.anchored==0]

  if preference=='anchored':
    availableCells = cells[cells.anchored==1]

  distances = []
  for i in range(0, len(availableCells)):
   distances.append(dist(x, y, availableCells.iloc[i]['x'], availableCells.iloc[i]['y']))
  availableCells.insert(len(availableCells.columns), 'distance', distances)
  availableCells = availableCells.sort_values('distance')
  # print("UE ID: ",id, "Preferred Cell: ", preference)
  # print(availableCells)

  for i in range(0, len(availableCells)):
    ac = availableCells.iloc[i]
    cell = cells.loc[cells['id']==ac['id']]
    # print(cell)
    x = int(cell['currCapacity'])
    # print(x-throughput)
    if((x-throughput) < 0):
      oloads.append(1)
      # print("Overloading")
    else:
      cell['currCapacity'] = cell['currCapacity'] - throughput
      cells.loc[cells['id']==ac['id']]=cell
      # ues.iloc[id-1]['allocatedCell'] = minId
      if(first==True):
        firsts.append({'ueId': int(id), 'allocatedCell': int(cell['id'])})
      return ac['id']
    #   print("Available")

  return False

for i in range(0,len(ues)):
  s = int(ues.loc[i]['slice'])
  ue = ues.loc[i]
  pref = policy[str(s)]
  res1 = findCell(int(ue['id']), pref['p1'], ue['x'], ue['y'], ue['throughput(Kbps)'], True)
  if res1!=False:
    # print("P1")
    ue['allocatedCell'] = res1
    ues.loc[i] = ue

  else:
    # print("P2")

    res2 = findCell(ue['id'], pref['p2'], ue['x'], ue['y'], ue['throughput(Kbps)'], False)
    if res2!=False:
      ue['allocatedCell'] = res2
      ues.iloc[i] = ue

    else:
      # print("P3")

      res3 = findCell(ue['id'], pref['p3'], ue['x'], ue['y'], ue['throughput(Kbps)'], False)
      if res3!=False:
        ue['allocatedCell'] = res3
        ues.iloc[i] = ue

      else:
        unmanaged = unmanaged+1
        # print('Sorry, no cell for this UE.')

for i in range(0,len(ues)):
  allocated.append({'ueId': int(ues.iloc[i]['id']), 'allocatedCell': int(ues.iloc[i]['allocatedCell'])})

print("Number of UEs managed: ", len(allocated))
percentageFirst = (len(firsts)/len(allocated))*100
print("Percentage of UEs allocated their first preferences: ", percentageFirst)
print("Overloads: ", len(oloads))
print("Unmanaged: ", unmanaged)

import matplotlib.pyplot as plt
import numpy as np

circle_centers = []
circle_radii = []
for i in range (0, len(cells['x'])):
  circle_centers.append((cells['x'][i], cells['y'][i]))
  circle_radii.append(cells['radius'][i])

# Plotting
plt.figure(figsize=(10, 10))

# Plot circular areas and add label numbers
for i, (center, radius) in enumerate(zip(circle_centers, circle_radii)):
    if radius == 6:
        circle = plt.Circle(center, radius, alpha=0.3, color='red')
    elif radius == 30:
        circle = plt.Circle(center, radius, alpha=0.3, color='blue')
    else:
        circle = plt.Circle(center, radius, alpha=0.3, color='lightblue')

    plt.gca().add_patch(circle)

    # Add label number inside the circle
    plt.text(center[0], center[1], str(i+1), color='black', ha='center', va='center')

# Adjust plot settings
plt.title('Arrangement of the cells in a 100 km x 100 km space')
plt.axis([0, 100, 0, 100])
a = ues['x'].to_list()
b = ues['y'].to_list()
c = ues['allocatedCell'].to_list()
plt.scatter(a, b)
for i, (x,y) in enumerate(zip(a,b)):
  # print(c[i], x, y)
  plt.text(x, y-1, str(c[i]), fontsize=10, color='red', ha='center', va='top')
# Show the plot
plt.show()

#RUNNING THIS BLOCK AGAIN FOR THE BASELINE POLICY PERFORMANCE
# Firsts: UEs which were allocated their first preference
# Allocated: the actual allocated cell IDs
# oloads: Number of times the allocation WOULD HAVE lead to an overload
# unmanaged: Number of UEs which could not be allocated any cell
firsts = []
allocated = []
oloads = []
unmanaged = 0

def findCell2(id, preference, x, y, throughput, first):
  if preference=='macro':
    availableCells = cells2[cells2.pico==0]
    # availableCells = availableCells[availableCells.anchored==0]

  if preference=='pico':
    availableCells = cells2[cells2.pico==1]
    # availableCells = availableCells[availableCells.anchored==0]

  distances = []
  for i in range(0, len(availableCells)):
   distances.append(dist(x, y, availableCells.iloc[i]['x'], availableCells.iloc[i]['y']))
  availableCells.insert(len(availableCells.columns), 'distance', distances)
  availableCells = availableCells.sort_values('distance')
  # print(availableCells)

  for i in range(0, len(availableCells)):
    ac = availableCells.iloc[i]
    cell = cells2.loc[cells2['id']==ac['id']]
    # print(cell)
    x = int(cell['currCapacity'])
    # print(x-throughput)
    if((x-throughput) < 0):
      oloads.append(1)
      # print("Overloading")
    else:
      cell['currCapacity'] = cell['currCapacity'] - throughput
      cells2.loc[cells2['id']==ac['id']]=cell
      # ues.iloc[id-1]['allocatedCell'] = minId
      if(first==True):
        firsts.append({'ueId': int(id), 'allocatedCell': int(cell['id'])})
      return ac['id']
    #   print("Available")

  return False

for i in range(0,len(ues)):
  s = int(ues.loc[i]['slice'])
  ue = ues.loc[i]
  pref = policy2[str(s)]
  res1 = findCell2(int(ue['id']), pref['p1'], ue['x'], ue['y'], ue['throughput(Kbps)'], True)
  if res1!=False:
    # print("P1")
    ue['allocatedCell'] = res1
    ues.loc[i] = ue

  else:
    # print("P2")

    res2 = findCell2(ue['id'], pref['p2'], ue['x'], ue['y'], ue['throughput(Kbps)'], False)
    if res2!=False:
      ue['allocatedCell'] = res2
      ues.iloc[i] = ue

    else:
      unmanaged = unmanaged+1
      # print('Sorry, no cell for this UE.')

for i in range(0,len(ues)):
  allocated.append({'ueId': int(ues.iloc[i]['id']), 'allocatedCell': int(ues.iloc[i]['allocatedCell'])})

print("Number of UEs managed: ", len(allocated))
percentageFirst = (len(firsts)/len(allocated))*100
print("Percentage of UEs allocated their first preferences: ", percentageFirst)
print("Overloads: ", len(oloads))
print("Unmanaged: ", unmanaged)

import matplotlib.pyplot as plt
import numpy as np

# Define circular areas
circle_centers = []
circle_radii = []
for i in range (0, len(cells2['x'])):
  circle_centers.append((cells2['x'][i], cells2['y'][i]))
  circle_radii.append(cells2['radius'][i])

# Plotting
plt.figure(figsize=(10, 10))

# Plot circular areas and add label numbers
for i, (center, radius) in enumerate(zip(circle_centers, circle_radii)):

    circle = plt.Circle(center, radius, alpha=0.3, color='lightblue')

    plt.gca().add_patch(circle)

    # Add label number inside the circle
    plt.text(center[0], center[1], str(i+1), color='black', ha='center', va='center')

# Adjust plot settings
plt.title('Arrangement of the cells in a 100 km x 100 km space')
plt.axis([0, 100, 0, 100])

a = ues['x'].to_list()
b = ues['y'].to_list()
c = ues['allocatedCell'].to_list()
plt.scatter(a, b)
for i, (x,y) in enumerate(zip(a,b)):
  # print(c[i], x, y)
  plt.text(x, y-1, str(c[i]), fontsize=10, color='red', ha='center', va='top')
# Show the plot

# Show the plot
plt.show()